# sort 算法的比较

## 比较型的算法

### 1. 冒泡排序 和 插入排序
**冒泡排序：一轮遍历结束，最大的数放置到最后**  
**插入排序：每一轮都与前面的有序数组进行比较排序**

- 平均时间复杂度是 n^2。
- 最差的时间复杂度是 n^2。 （数组是反着排序的）
- 最好的情况下时间复杂度是：n。（在几乎排序完成的数组上。但是 插入排序的性能要好于 普通冒泡排序（普通冒泡排序的时间复杂度不是 n））
- 都是稳定的。
- 空间复杂度为 1

> 冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^{2})次交换，而插入排序只要最多 O(n)交换。冒泡排序的实现通常会对已经排序好的数列拙劣地运行 O(n^{2}），而插入排序在这个例子只需要 O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。

插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择

### 2. 希尔排序 shellSort

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

**希尔排序：希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）**

- 时间复杂度：根据步长序列的不同而不同
- 最好的情况下时间复杂度是：n
- 不稳定。
- 空间复杂度为 1

希尔排序不仅效率较高（比冒泡和插入高），它的代码相对要简短，低开销（继承插入排序的优点），追求这些特点（效率要求过得去就好，代码简短，开销低，且数据量较小）的时候希尔排序是好的 O(n·log(n)) 算法的替代品。

### 3. 选择排序

**选择排序：每一轮都是选出最小的数，放置该位置上**

- 平均，最好，最差时间复杂度都是 n^2。
- 不稳定。
- 空间复杂度为 1

> 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

所以对于交换位置所消耗的性能较大的可以使用 选择排序

### 4. 归并排序 MergeSort

**归并排序：递归地把当前序列平均分割成两半， 在保持元素顺序的同时将上一步得到的子序列集成到一起**

- 时间复杂度都是 n(log(n))
- 稳定 (在 O(n·log(n)) 时间复杂度的排序算法中，归并排序是唯一稳定的)
- 空间复杂度为 n

空间换时间，并且稳定，保持稳定性这一点是它的亮点

### 5. 堆排序 HeapSort

**堆排序：把数组转换成最大堆积。重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。**

- 时间复杂度都是 n(log(n))
- 不稳定
- 空间复杂度为 1 （in-place algorithm）

可以认为是 选择排序的改进版：它将数组分为已排序和未排序的区域，并通过提取最大元素并将其移动到已排序区域来迭代缩小未排序区域。

### 6. 快速排序 QuickSort

**快速排序：从数列中挑出一个元素。大的放入一个数组，小的放入一个数组，然后合并。递归执行**

- 时间复杂度都是 n(log(n))
- 最坏时间复杂度是 n^2 (但这种状况并不常见)
- 不稳定
- 空间复杂度根据实现的方式不同而不同

事实上，快速排序 n(log(n)) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。
