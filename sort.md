# sort 算法的比较

## 比较型的算法

### 1. 冒泡排序 和 插入排序

**冒泡排序：一轮遍历结束，最大的数放置到最后**  
**插入排序：每一轮都与前面的有序数组进行比较排序**

- 平均时间复杂度是 n^2。
- 最差的时间复杂度是 n^2。 （数组是反着排序的）
- 最好的情况下时间复杂度是：n。（在几乎排序完成的数组上。但是 插入排序的性能要好于 普通冒泡排序（普通冒泡排序的时间复杂度不是 n））
- 都是稳定的。
- 空间复杂度为 1

> 冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^{2})次交换，而插入排序只要最多 O(n)交换。冒泡排序的实现通常会对已经排序好的数列拙劣地运行 O(n^{2}），而插入排序在这个例子只需要 O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。

插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择

### 2. 希尔排序 shellSort

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

**希尔排序：希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）**

- 时间复杂度：根据步长序列的不同而不同
- 最好的情况下时间复杂度是：n
- 不稳定。
- 空间复杂度为 1

希尔排序不仅效率较高（比冒泡和插入高），它的代码相对要简短，低开销（继承插入排序的优点），追求这些特点（效率要求过得去就好，代码简短，开销低，且数据量较小）的时候希尔排序是好的 O(n·log(n)) 算法的替代品。

### 3. 选择排序

**选择排序：每一轮都是选出最小的数，放置该位置上**

- 平均，最好，最差时间复杂度都是 n^2。
- 不稳定。
- 空间复杂度为 1

> 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

所以对于交换位置所消耗的性能较大的可以使用 选择排序

### 4. 归并排序 MergeSort

**归并排序：递归地把当前序列平均分割成两半， 在保持元素顺序的同时将上一步得到的子序列集成到一起**

- 时间复杂度都是 n(log(n))
- 稳定 (在 O(n·log(n)) 时间复杂度的排序算法中，归并排序是唯一稳定的)
- 空间复杂度为 n

空间换时间，并且稳定，保持稳定性这一点是它的亮点

### 5. 堆排序 HeapSort

**堆排序：把数组转换成最大堆积。重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。**

- 时间复杂度都是 n(log(n))
- 不稳定
- 空间复杂度为 1 （in-place algorithm）

可以认为是 选择排序的改进版：它将数组分为已排序和未排序的区域，并通过提取最大元素并将其移动到已排序区域来迭代缩小未排序区域。

### 6. 快速排序 QuickSort

**快速排序：从数列中挑出一个元素。大的放入一个数组，小的放入一个数组，然后合并。递归执行**

- 时间复杂度是 n(log(n))
- 最坏时间复杂度是 n^2 (但这种状况并不常见)
- 不稳定
- 空间复杂度根据实现的方式不同而不同

事实上，快速排序 n(log(n)) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。

## 非比较型的算法

### 计数排序

**计数排序：统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项。最后从该数组依次取出数字**

- 时间复杂度都是 n+k (当输入的元素是 n 个 0 到 k 之间的整数时)
- 最坏空间复杂度是 n+k
- 稳定

计数排序是一种根据小整数键对对象集合进行排序的算法;也就是说，它是一个整数排序算法。它通过计算具有每个不同键值的对象的数量来操作，并对这些计数使用算术来确定输出序列中每个键值的位置。其运行时间与项目数量和最大和最小键值之间的差异是线性的，这使得计数排序对于数据范围很大的数组，需要大量时间和内存。因此它仅适用于键的变化不大于项目数的情况下的直接使用。例如：计数排序是用来排序 0 到 100 之间的数字的最好的算法。

**计数排序不是比较排序，排序的速度快于任何比较排序算法。**

> However, it is often used as a subroutine in another sorting algorithm, radix sort, that can handle larger keys more efficiently

### 基数排序

**基数排序：将整数按位数切割成不同的数字，然后按每个位数分别比较**

- 时间复杂度是 k \* n，其中 n 是排序元素个数，k 是数字位数
- 最坏空间复杂度 {\displaystyle O(k+N)} {\displaystyle O(k+N)}
- 稳定

> 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且在适当选择之下， k 一般不大于 log n，所以基数排序一般要快过基于比较的排序，比如快速排序。

### 桶排序

**桶排序：将数据分到有限数量的桶里，每个桶再分别排序**

- 最坏时间复杂度 n^2 (if all elements belong to same bucket)
- 平均时间复杂度 n+k (where k is the number of buckets)
- 稳定

> Bucket sort can be implemented with comparisons and therefore can also be considered a comparison sort algorithm.

桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。
